<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version  -->

<!DOCTYPE rfc SYSTEM "../Tools/rfc2629xslt/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-stenberg-httpbis-tcp-01" category="bcp">

  <front>
    <title abbrev="TCP for HTTP">TCP Tuning for HTTP</title>

    <author initials="D." surname="Stenberg" fullname="Daniel Stenberg">
      <organization>Mozilla</organization>
      <address>
        <email>daniel@haxx.se</email>
        <uri>http://daniel.haxx.se</uri>
      </address>
    </author>

    <date year="2015"/>

    <area>General</area>
    <workgroup>httpbis</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document records current best practice for using all versions of HTTP over TCP.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP version 1.1 <xref target="RFC7230"/> as well as HTTP version 2 <xref target="RFC7540"/> are defined
to use TCP <xref target="RFC0793"/>, and their performance can depend greatly upon how TCP
is configured. This document records the best current practice for using HTTP
over TCP, with a focus on improving end-user perceived performance.</t>

<t>These practices are generally applicable to HTTP/1 as well as HTTP/2, although
some may note particular impact or nuance regarding a particular protocol
version.</t>

<t>There are countless scenarios, roles and setups where HTTP is being using so
there can be no single specific “Right Answer” to most TCP questions. This
document intends only to cover the most important areas of concern and suggest
possible actions.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in <xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="socket-planning" title="Socket planning">

<t>Your HTTP server or intermediary may need configuration changes to some system
tunables and timeout periods to perform optimally. Actual values will depend
on how you are scaling the platform, horizontally or vertically, and other
connection semantics. Changing system limits and altering thresholds will
change the behavior of your web service and its dependencies. These
dependencies are usually common to other services running on the same system,
so good planning and testing is advised.</t>

<t>This is a list of values to consider and some general advice on how those
values can be modified on Linux systems.</t>

<section anchor="number-of-open-files" title="Number of open files">

<t>A modern HTTP server will serve a large number of TCP connections and in most
systems each open socket equals an open file. Make sure that limit isn’t a
bottle neck. In Linux, the limit can be raised like this:</t>

<figure><artwork><![CDATA[
fs.file-max = <number of files>
]]></artwork></figure>

</section>
<section anchor="number-of-concurrent-network-messages" title="Number of concurrent network messages">

<t>Raise the number of packets allowed to get queued when a particular interface
receives packets faster than the kernel can process them. In Linux, this limit
can be raised like this:</t>

<figure><artwork><![CDATA[
net.core.netdev_max_backlog = <number of packets>
]]></artwork></figure>

</section>
<section anchor="number-of-incoming-tcp-syns-allowed-to-backlog" title="Number of incoming TCP SYNs allowed to backlog">

<t>The number of new connection requests that are allowed to queue up in the
kernel. In Linux, this limit can be raised like this:</t>

<figure><artwork><![CDATA[
net.core.somaxconn = <number>
]]></artwork></figure>

</section>
<section anchor="use-the-whole-port-range-for-local-ports" title="Use the whole port range for local ports">

<t>To make sure the TCP stack can take full advantage of the entire set of
possible sockets, give it a larger range of local port numbers to use.</t>

<figure><artwork><![CDATA[
net.ipv4.ip_local_port_range = 1024 65535
]]></artwork></figure>

</section>
<section anchor="lower-the-tcp-fin-timeout" title="Lower the TCP FIN timeout">

<t>High connection completion rates will consume ephemeral ports quickly.  Lower
the time during which connections are in FIN-WAIT-2/TIME_WAIT states so that
they can be purged faster and thus maintain a maximal number of available
sockets. The primitives for the assignment of these values were described in
<xref target="RFC0793"/>, however significantly lower values are commonly used.</t>

<figure><artwork><![CDATA[
net.ipv4.tcp_fin_timeout = <number of seconds>
]]></artwork></figure>

</section>
<section anchor="reuse-sockets-in-timewait-state" title="Reuse sockets in TIME_WAIT state">

<t>When running backend servers on a managed, low latency network you might allow
the reuse of sockets in TIME_WAIT state for new connections when a protocol
complete termination has occurred. There is no RFC that covers this behaviour.</t>

<figure><artwork><![CDATA[
net.ipv4.tcp_tw_reuse = 1
]]></artwork></figure>

</section>
<section anchor="tcp-socket-buffer-sizes-and-window-scaling" title="TCP socket buffer sizes and Window Scaling">

<t>Systems meant to handle and serve a huge number of TCP connections at high
speeds need a significant amount of memory for TCP socket buffers. On some
systems you can tell the TCP stack what default buffer sizes to use and how
much they are allowed to dynamically grow and shrink.  Window Scaling is
typically linked to socket buffer sizes and on a Linux system can be
controlled with the values:</t>

<figure><artwork><![CDATA[
net.ipv4.tcp_wmem = <minimum size> <default size> <max size in bytes>
net.ipv4.tcp_rmem = <minimum size> <default size> <max size in bytes>
]]></artwork></figure>

<t>The minimum and default tend to require less proactive amendment than the
maximum value. When deriving maximum values for use, you should consider the
BDP (Bandwidth Delay Product) of the target environment and clients.  Consider
also that ‘read’ and ‘write’ values do not require to be synchronised, as the
BDP requirements for a load balancer or middle-box might be very different
when acting as a sender or receiver.</t>

<t>Allowing needlessly high values beyond the expected limitations of the
platform might increase the probability of retransmissions and buffer induced
delays within the path. Extensions such as ECN coupled with AQM can help
mitigate this undesirable behaviour <xref target="RFC7141"/>.</t>

<t><xref target="RFC7323"/> covers Window Scaling in greater detail.</t>

</section>
<section anchor="set-maximum-allowed-tcp-window-sizes" title="Set maximum allowed TCP window sizes">

<t>You may have to increase the largest allowed window size. Window scaling must
be accommodated within the maximal values, however it is not uncommon to see
the maximum definable higher than the scalable limit; these values can
statically defined within socket parameters (SO_RCVBUF,SO_SNDBUF)</t>

<figure><artwork><![CDATA[
net.core.rmem_max = <number of bytes>
net.core.wmem_max = <number of bytes>
]]></artwork></figure>

</section>
<section anchor="timers-and-timeouts" title="Timers and timeouts">

<t>On a modern shared platform it can be common to plan for both long and short
lived connections on the same implementation. However, the delivery of static
assets and a ‘web push’ or ‘long poll’ service provide very different quality
of service promises.</t>

<t>Fail ‘fast’: TCP resources can be highly contended. For fault tolerance
reasons a server needs to be able to determine within a reasonable time frame
whether a connection is still active or required. e.g. If static assets
typically return in 100s of milliseconds, and users ‘switch off’ after &lt;10s
keeping timeouts of &gt;30s make little sense and defining a ‘quality of service’
appropriate to the target platform is encouraged. On a shared platform with
mixed session lifetimes, applications that require longer render times have various
options to ensure the underlying service and upstream servers in the path can
identify the session as not failed: HTTP continuations, Redirects, 202s or
sending data.</t>

<t>Clients and servers typically have many timeout options, a few notable options
are: Connect(client), time to request(server), time to first byte(client),
between bytes(server/client), total connection time(server/client). Some
implementations merge these values into a single ‘timeout’ definition even
when statistics are reported individually. All should be considered as the
defaults in many implementations are highly underiable, even infinite timeouts
have been observed.</t>

</section>
</section>
<section anchor="tcp-handshake" title="TCP handshake">

<section anchor="tcp-fast-open" title="TCP Fast Open">

<t>TCP Fast Open (a.k.a. TFO, <xref target="RFC7413"/>) allows data to be sent on the TCP
handshake, thereby allowing a request to be sent without any delay if a
connection is not open.</t>

<t>TFO requires both client and server support, and additionally requires
application knowledge, because the data sent on the SYN needs to be
idempotent. Therefore, TFO can only be used on idempotent, safe HTTP methods
(e.g., GET and HEAD), or with intervening negotiation (e.g, using TLS). It
should be noted that TFO requires a secret to be defined on the server to
mitigate security vulnerabilities it introduces. TFO therefore requires more
server side deployment planning than other enhancements.</t>

<t>Support for TFO is growing in client platforms, especially mobile, due to the
significant performance advantage it gives.</t>

</section>
<section anchor="initial-congestion-window" title="Initial Congestion Window">

<t><xref target="RFC6928"/> specifies an initcwnd (initial congestion window) of 10, and is
now fairly widely deployed server-side. There has been experimentation with
larger initial windows, in combination with packet pacing. Many
implementations allow initcwnd to be applied to specific routes which allows a
greater degree of flexibility than some other TCP parameters.</t>

<t>IW10 has been reported to perform fairly well even in high volume servers.</t>

</section>
<section anchor="tcp-syn-flood-handling" title="TCP SYN flood handling">

<t>TCP SYN Flood mitigations <xref target="RFC4987"/> are necessary and there will be
thresholds to tweak.</t>

</section>
</section>
<section anchor="tcp-transfers" title="TCP transfers">

<section anchor="packet-pacing" title="Packet Pacing">

<t>TBD</t>

</section>
<section anchor="explicit-congestion-control" title="Explicit Congestion Control">

<t>Apple <eref target="https://developer.apple.com/videos/wwdc/2015/?id=719">deploying in iOS and OSX</eref>.</t>

</section>
<section anchor="nagles-algorithm" title="Nagle’s Algorithm">

<t>Nagle’s Algorithm <xref target="RFC0896"/> is the mechanism that makes the TCP stack hold
(small) outgoing packets for a short period of time so that it can
potentially merge that packet with the next outgoing one. It is optimized for
throughput at the expense of latency.</t>

<t>HTTP/2 in particular requires that the client can send a packet back fast even
during transfers that are perceived as single direction transfers. Even small
delays in those sends can cause a significant performance loss.</t>

<t>HTTP/1.1 is also affected, especially when sending off a full request in a
single write() system call.</t>

<t>In POSIX systems you switch it off like this:</t>

<figure><artwork><![CDATA[
int one = 1;
setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
]]></artwork></figure>

</section>
<section anchor="keep-alive" title="Keep-alive">

<t>TCP keep-alive is likely disabled - at least on mobile clients for energy
saving purposes. App-level keep-alive is then required for long-lived requests
to detect failed peers or connections reset by stateful firewalls etc.</t>

</section>
</section>
<section anchor="re-using-connections" title="Re-using connections">

<section anchor="slow-start-after-idle" title="Slow Start after Idle">

<t>Slow-start is one of the algorithms that TCP uses to control congestion inside
the network. It is also known as the exponential growth phase. Each TCP
connection will start off in slow-start but will also go back to slow-start
after a certain amount of idle time.</t>

<t>In Linux systems you can prevent the TCP stack from going back to slow-start
after idle by settting</t>

<figure><artwork><![CDATA[
net.ipv4.tcp_slow_start_after_idle = 0
]]></artwork></figure>

</section>
<section anchor="tcp-bound-authentications" title="TCP-Bound Authentications">

<t>There are several HTTP authentication mechanisms in use today that are used or
can be used to authenticate a connection rather than a single HTTP
request. Two popular ones are NTLM and Negotiate.</t>

<t>If such an authentication has been negotiated on a TCP connection, that
connection can remain authenticated throughout the rest of its lifetime. This
discrepancy with how other HTTP authentications work makes it important to
handle these connections with care.</t>

</section>
</section>
<section anchor="closing-connections" title="Closing connections">

<section anchor="half-close" title="Half-close">

<t>The client or server is free to half-close after a request or response has been
completed; or when there is no pending stream in HTTP/2.</t>

<t>Half-closing is sometimes the only way for a server to make sure it closes
down connections cleanly so that it doesn’t accept more requests while still
allowing clients to receive the ongoing responses.</t>

</section>
<section anchor="abort" title="Abort">

<t>No client abort for HTTP/1.1 after the request body has been sent. Delayed
full close is expected following an error response to avoid RST on the client.</t>

</section>
<section anchor="close-idle-connections" title="Close Idle Connections">

<t>Keeping open connections around for subsequent connection reuse is key for
many HTTP clients’ performance. The value of an existing connection quickly
degrades and after only a few minutes the chance that a connection will
successfully get reused by a web browser is slim.</t>

</section>
<section anchor="tail-loss-probes" title="Tail Loss Probes">

<t><eref target="http://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">draft</eref></t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document does not require action from IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TBD</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC7413' target='http://www.rfc-editor.org/info/rfc7413'>
<front>
<title>TCP Fast Open</title>
<author initials='Y.' surname='Cheng' fullname='Y. Cheng'><organization /></author>
<author initials='J.' surname='Chu' fullname='J. Chu'><organization /></author>
<author initials='S.' surname='Radhakrishnan' fullname='S. Radhakrishnan'><organization /></author>
<author initials='A.' surname='Jain' fullname='A. Jain'><organization /></author>
<date year='2014' month='December' />
<abstract><t>This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t></abstract>
</front>
<seriesInfo name='RFC' value='7413'/>
<seriesInfo name='DOI' value='10.17487/RFC7413'/>
</reference>



<reference  anchor='RFC6928' target='http://www.rfc-editor.org/info/rfc6928'>
<front>
<title>Increasing TCP's Initial Window</title>
<author initials='J.' surname='Chu' fullname='J. Chu'><organization /></author>
<author initials='N.' surname='Dukkipati' fullname='N. Dukkipati'><organization /></author>
<author initials='Y.' surname='Cheng' fullname='Y. Cheng'><organization /></author>
<author initials='M.' surname='Mathis' fullname='M. Mathis'><organization /></author>
<date year='2013' month='April' />
<abstract><t>This document proposes an experiment to increase the permitted TCP initial window (IW) from between 2 and 4 segments, as specified in RFC 3390, to 10 segments with a fallback to the existing recommendation when performance issues are detected.  It discusses the motivation behind the increase, the advantages and disadvantages of the higher initial window, and presents results from several large-scale experiments showing that the higher initial window improves the overall performance of many web services without resulting in a congestion collapse.  The document closes with a discussion of usage and deployment for further experimental purposes recommended by the IETF TCP Maintenance and Minor Extensions (TCPM) working group.</t></abstract>
</front>
<seriesInfo name='RFC' value='6928'/>
<seriesInfo name='DOI' value='10.17487/RFC6928'/>
</reference>



<reference  anchor='RFC0896' target='http://www.rfc-editor.org/info/rfc896'>
<front>
<title>Congestion Control in IP/TCP Internetworks</title>
<author initials='J.' surname='Nagle' fullname='J. Nagle'><organization /></author>
<date year='1984' month='January' />
<abstract><t>This memo discusses some aspects of congestion control in IP/TCP    Internetworks.  It is intended to stimulate thought and further    discussion of this topic.  While some specific suggestions are made    for improved congestion control implementation, this memo does not    specify any standards.</t></abstract>
</front>
<seriesInfo name='RFC' value='896'/>
<seriesInfo name='DOI' value='10.17487/RFC0896'/>
</reference>



<reference  anchor='RFC4987' target='http://www.rfc-editor.org/info/rfc4987'>
<front>
<title>TCP SYN Flooding Attacks and Common Mitigations</title>
<author initials='W.' surname='Eddy' fullname='W. Eddy'><organization /></author>
<date year='2007' month='August' />
<abstract><t>This document describes TCP SYN flooding attacks, which have been well-known to the community for several years.  Various countermeasures against these attacks, and the trade-offs of each, are described.  This document archives explanations of the attack and common defense techniques for the benefit of TCP implementers and administrators of TCP servers or networks, but does not make any standards-level recommendations.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='4987'/>
<seriesInfo name='DOI' value='10.17487/RFC4987'/>
</reference>



<reference  anchor='RFC7141' target='http://www.rfc-editor.org/info/rfc7141'>
<front>
<title>Byte and Packet Congestion Notification</title>
<author initials='B.' surname='Briscoe' fullname='B. Briscoe'><organization /></author>
<author initials='J.' surname='Manner' fullname='J. Manner'><organization /></author>
<date year='2014' month='February' />
<abstract><t>This document provides recommendations of best current practice for dropping or marking packets using any active queue management (AQM) algorithm, including Random Early Detection (RED), BLUE, Pre- Congestion Notification (PCN), and newer schemes such as CoDel (Controlled Delay) and PIE (Proportional Integral controller Enhanced).  We give three strong recommendations: (1) packet size should be taken into account when transports detect and respond to congestion indications, (2) packet size should not be taken into account when network equipment creates congestion signals (marking, dropping), and therefore (3) in the specific case of RED, the byte- mode packet drop variant that drops fewer small packets should not be used.  This memo updates RFC 2309 to deprecate deliberate preferential treatment of small packets in AQM algorithms.</t></abstract>
</front>
<seriesInfo name='BCP' value='41'/>
<seriesInfo name='RFC' value='7141'/>
<seriesInfo name='DOI' value='10.17487/RFC7141'/>
</reference>



<reference  anchor='RFC7323' target='http://www.rfc-editor.org/info/rfc7323'>
<front>
<title>TCP Extensions for High Performance</title>
<author initials='D.' surname='Borman' fullname='D. Borman'><organization /></author>
<author initials='B.' surname='Braden' fullname='B. Braden'><organization /></author>
<author initials='V.' surname='Jacobson' fullname='V. Jacobson'><organization /></author>
<author initials='R.' surname='Scheffenegger' fullname='R. Scheffenegger' role='editor'><organization /></author>
<date year='2014' month='September' />
<abstract><t>This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths.  It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics.  The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.</t><t>This document obsoletes RFC 1323 and describes changes from it.</t></abstract>
</front>
<seriesInfo name='RFC' value='7323'/>
<seriesInfo name='DOI' value='10.17487/RFC7323'/>
</reference>




    </references>


<section anchor="acknowledgments" title="Acknowledgments">

<t>This specification builds upon previous work and help from
Mark Nottingham, Craig Taylor</t>

</section>


  </back>
</rfc>

